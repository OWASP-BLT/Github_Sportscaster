<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Activity Sportscaster</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .stats {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        /* Sound toggle button */
        .sound-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .sound-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .sound-toggle.muted {
            opacity: 0.5;
        }

        /* Sportscaster Announcement Section */
        .sportscaster-section {
            max-width: 900px;
            margin: 0 auto 30px;
            display: flex;
            align-items: center;
            gap: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 20px;
            border: 3px solid rgba(255, 215, 0, 0.6);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }

        .robot-container {
            flex-shrink: 0;
            width: 120px;
            height: 140px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .robot-svg {
            width: 100%;
            height: 100%;
        }

        @keyframes robot-talk {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(0.7); }
        }

        .robot-mouth {
            animation: robot-talk 0.3s ease-in-out infinite;
            transform-origin: center;
        }

        @keyframes robot-blink {
            0%, 90%, 100% { transform: scaleY(1); }
            95% { transform: scaleY(0.1); }
        }

        .robot-eye {
            animation: robot-blink 3s ease-in-out infinite;
            transform-origin: center;
        }

        @keyframes antenna-glow {
            0%, 100% { fill: #ff4444; filter: drop-shadow(0 0 5px #ff4444); }
            50% { fill: #ffff00; filter: drop-shadow(0 0 10px #ffff00); }
        }

        .antenna-light {
            animation: antenna-glow 1s ease-in-out infinite;
        }

        .tv-screen {
            flex-grow: 1;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            padding: 20px;
            border: 4px solid #333;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5), 0 0 15px rgba(100, 100, 255, 0.3);
            position: relative;
            overflow: hidden;
            min-height: 120px;
        }

        .tv-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
        }

        .tv-label {
            position: absolute;
            top: 8px;
            left: 12px;
            font-size: 0.7em;
            color: #ff4444;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        @keyframes live-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .live-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #ff4444;
            border-radius: 50%;
            margin-right: 5px;
            animation: live-pulse 1s ease-in-out infinite;
        }

        .announcement-content {
            margin-top: 15px;
        }

        .announcement-event-type {
            font-size: 0.9em;
            color: #ffd700;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .announcement-repo {
            font-size: 1.4em;
            font-weight: bold;
            color: #fff;
            overflow-wrap: break-word;
        }

        .announcement-repo a {
            color: #fff;
            text-decoration: none;
        }

        .announcement-repo a:hover {
            text-decoration: underline;
            color: #ffd700;
        }

        .announcement-time {
            font-size: 0.8em;
            color: #888;
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .view-link {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
            padding: 4px 10px;
            border-radius: 12px;
            text-decoration: none;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .view-link:hover {
            background: rgba(255, 215, 0, 0.4);
            color: #fff;
        }

        .no-announcement {
            color: #888;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        /* Compact Inline Stats for Event Items */
        .event-stats {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
            flex-shrink: 0;
        }

        .stat-pill {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            background: rgba(0, 0, 0, 0.2);
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7em;
        }

        .stat-pill-icon {
            font-size: 0.9em;
        }

        .stat-pill-value {
            font-weight: bold;
            color: #ffd700;
        }

        /* Event Type Tags (compact) */
        .event-type-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
        }

        .mini-tag {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.65em;
        }

        .mini-tag-count {
            font-weight: bold;
            color: #ffd700;
        }

        /* Activity mini-bar */
        .mini-activity-bar {
            width: 50px;
            height: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        .mini-activity-fill {
            height: 100%;
            background: linear-gradient(90deg, #48bb78, #ffd700);
            border-radius: 2px;
        }

        /* Trending badge */
        .trending-badge {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 8px;
        }

        .trending-badge.up {
            background: rgba(72, 187, 120, 0.3);
            color: #48bb78;
        }

        .trending-badge.down {
            background: rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
        }

        .trending-badge.new {
            background: rgba(255, 215, 0, 0.3);
            color: #ffd700;
        }

        /* Event List Section */
        .list-container {
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .event-item {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px 15px;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .event-item:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            border-color: rgba(255, 215, 0, 0.5);
        }

        .event-item-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .event-number {
            background: rgba(255, 255, 255, 0.2);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8em;
            flex-shrink: 0;
        }

        .event-details {
            flex-grow: 1;
            min-width: 0;
        }

        .event-repo-name {
            font-size: 1em;
            font-weight: bold;
            overflow-wrap: break-word;
        }

        .event-repo-name a {
            color: #fff;
            text-decoration: none;
        }

        .event-repo-name a:hover {
            text-decoration: underline;
            color: #ffd700;
        }

        .event-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 3px;
            flex-wrap: wrap;
        }

        .event-type {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 5px;
            font-size: 0.7em;
        }

        .event-time {
            font-size: 0.75em;
            opacity: 0.7;
        }

        /* Slide in animation for new events */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .event-item.new-event {
            animation: slideIn 0.4s ease-out;
            border-color: rgba(255, 215, 0, 0.8);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        /* Blink animation for new activity */
        @keyframes blink {
            0%, 100% { 
                background: rgba(255, 255, 255, 0.1);
                border-color: rgba(255, 255, 255, 0.2);
            }
            50% { 
                background: rgba(255, 215, 0, 0.4);
                border-color: rgba(255, 215, 0, 0.8);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            }
        }

        .blink {
            animation: blink 0.6s ease-in-out 2;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.5em;
        }

        .error {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: #ff6b6b;
        }

        /* Pulse animation for loading */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .pulse {
            animation: pulse 1.5s ease-in-out infinite;
        }

        .refresh-info {
            text-align: center;
            margin-top: 20px;
            opacity: 0.8;
            font-size: 0.9em;
        }

        /* Rate Limit & Refresh Progress Styles */
        .api-status {
            max-width: 900px;
            margin: 0 auto 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 15px 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .api-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .rate-limit-info {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .rate-limit-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9em;
        }

        .rate-limit-label {
            opacity: 0.7;
        }

        .rate-limit-value {
            font-weight: bold;
            color: #48bb78;
        }

        .rate-limit-value.warning {
            color: #ecc94b;
        }

        .rate-limit-value.danger {
            color: #fc8181;
        }

        .refresh-countdown {
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .countdown-value {
            font-weight: bold;
            min-width: 25px;
            text-align: right;
        }

        .progress-bar-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #48bb78, #38a169);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .progress-bar.loading {
            background: linear-gradient(90deg, #ecc94b, #d69e2e);
            animation: pulse 0.5s ease-in-out infinite;
        }

        /* Speed Control Slider */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .speed-control-label {
            font-size: 0.85em;
            opacity: 0.8;
            white-space: nowrap;
        }

        .speed-slider {
            flex-grow: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #48bb78;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }

        .speed-slider::-webkit-slider-thumb:hover {
            background: #38a169;
        }

        .speed-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #48bb78;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .speed-value {
            font-size: 0.85em;
            font-weight: bold;
            min-width: 40px;
            text-align: right;
        }

        .auto-protect {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8em;
            margin-left: 10px;
        }

        .auto-protect input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .auto-protect-label {
            opacity: 0.8;
            cursor: pointer;
        }

        .rate-protected {
            color: #ecc94b;
            font-size: 0.8em;
            margin-left: 5px;
        }

        /* Staggered event animation */
        @keyframes staggerSlideIn {
            from {
                opacity: 0;
                transform: translateX(-30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }

        .event-item.stagger-in {
            animation: staggerSlideIn 0.4s ease-out forwards;
            opacity: 0;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .sportscaster-section {
                flex-direction: column;
                text-align: center;
            }

            .robot-container {
                width: 80px;
                height: 100px;
            }

            .tv-screen {
                width: 100%;
            }

            .announcement-repo {
                font-size: 1.1em;
            }

            .projects-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .sound-toggle {
                width: 40px;
                height: 40px;
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <!-- Sound Toggle Button -->
    <button class="sound-toggle" id="sound-toggle" title="Toggle Sound Effects">üîä</button>

    <div class="header">
        <h1>‚ö° GitHub Activity Sportscaster</h1>
        <p>Real-time feed of GitHub repository activity</p>
    </div>

    <div class="stats">
        <span id="event-count">0</span> events processed | 
        <span id="repo-count">0</span> repositories tracked |
        Last update: <span id="last-update">-</span>
    </div>

    <!-- Sportscaster Announcement Section -->
    <div class="sportscaster-section" id="sportscaster">
        <div class="robot-container">
            <svg class="robot-svg" viewBox="0 0 100 120" xmlns="http://www.w3.org/2000/svg">
                <!-- Antenna -->
                <line x1="50" y1="10" x2="50" y2="25" stroke="#888" stroke-width="3"/>
                <circle class="antenna-light" cx="50" cy="7" r="5" fill="#ff4444"/>
                
                <!-- Head -->
                <rect x="20" y="25" width="60" height="45" rx="10" fill="#4a5568" stroke="#2d3748" stroke-width="2"/>
                
                <!-- Eyes -->
                <g class="robot-eye">
                    <circle cx="35" cy="45" r="8" fill="#1a202c"/>
                    <circle cx="35" cy="45" r="5" fill="#48bb78"/>
                    <circle cx="37" cy="43" r="2" fill="#fff"/>
                </g>
                <g class="robot-eye">
                    <circle cx="65" cy="45" r="8" fill="#1a202c"/>
                    <circle cx="65" cy="45" r="5" fill="#48bb78"/>
                    <circle cx="67" cy="43" r="2" fill="#fff"/>
                </g>
                
                <!-- Mouth/Speaker -->
                <g class="robot-mouth">
                    <rect x="35" y="58" width="30" height="8" rx="2" fill="#1a202c"/>
                    <line x1="40" y1="62" x2="45" y2="62" stroke="#48bb78" stroke-width="2"/>
                    <line x1="48" y1="62" x2="53" y2="62" stroke="#48bb78" stroke-width="2"/>
                    <line x1="56" y1="62" x2="61" y2="62" stroke="#48bb78" stroke-width="2"/>
                </g>
                
                <!-- Neck -->
                <rect x="40" y="70" width="20" height="10" fill="#718096"/>
                
                <!-- Body -->
                <rect x="15" y="80" width="70" height="35" rx="8" fill="#4a5568" stroke="#2d3748" stroke-width="2"/>
                
                <!-- Chest display -->
                <rect x="30" y="88" width="40" height="20" rx="3" fill="#1a202c"/>
                <text x="50" y="102" text-anchor="middle" fill="#48bb78" font-size="8" font-family="monospace">LIVE</text>
                
                <!-- Arms -->
                <rect x="5" y="82" width="10" height="25" rx="5" fill="#718096"/>
                <rect x="85" y="82" width="10" height="25" rx="5" fill="#718096"/>
            </svg>
        </div>
        <div class="tv-screen">
            <div class="tv-label"><span class="live-indicator"></span>LIVE</div>
            <div class="announcement-content" id="announcement">
                <div class="no-announcement">Waiting for activity...</div>
            </div>
        </div>
    </div>

    <!-- API Status & Refresh Progress -->
    <div class="api-status" id="api-status">
        <div class="api-status-header">
            <div class="rate-limit-info">
                <div class="rate-limit-item">
                    <span class="rate-limit-label">API Requests:</span>
                    <span class="rate-limit-value" id="rate-remaining">-</span>
                    <span class="rate-limit-label">/ </span>
                    <span class="rate-limit-value" id="rate-limit">-</span>
                </div>
                <div class="rate-limit-item">
                    <span class="rate-limit-label">Resets in:</span>
                    <span class="rate-limit-value" id="rate-reset">-</span>
                </div>
            </div>
            <div class="refresh-countdown">
                <span>Next refresh:</span>
                <span class="countdown-value" id="countdown">-</span>
                <span>s</span>
            </div>
        </div>
        <div class="progress-bar-container">
            <div class="progress-bar" id="progress-bar" style="width: 100%;"></div>
        </div>
        <div class="speed-control">
            <span class="speed-control-label">Refresh Speed:</span>
            <input type="range" class="speed-slider" id="speed-slider" min="5" max="60" value="10" step="5">
            <span class="speed-value" id="speed-value">10s</span>
            <div class="auto-protect">
                <input type="checkbox" id="auto-protect" checked>
                <label for="auto-protect" class="auto-protect-label" title="Automatically slow down when rate limit is low">Auto-protect</label>
            </div>
            <span class="rate-protected" id="rate-protected" style="display: none;">‚ö†Ô∏è Throttled</span>
        </div>
    </div>

    <div class="loading pulse" id="loading">Loading GitHub activity...</div>
    <div class="error" id="error" style="display: none;"></div>
    
    <div class="list-container" id="event-list"></div>

    <div class="refresh-info">
        Use the slider to control refresh speed | üîä Click sound button to toggle audio
    </div>

    <script>
        // Sound Effects Manager using Web Audio API
        class SoundEffects {
            constructor() {
                this.audioContext = null;
                this.enabled = true;
                this.initAudioContext();
            }

            initAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.enabled = false;
                }
            }

            resumeContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }

            toggle() {
                this.enabled = !this.enabled;
                return this.enabled;
            }

            // Play a note with given frequency and duration
            playNote(frequency, duration, type = 'sine', volume = 0.3) {
                if (!this.enabled || !this.audioContext) return;
                
                this.resumeContext();
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            // Different sound effects for each event type
            playPushEvent() {
                // Upward arpeggio - energetic push sound
                this.playNote(392, 0.1, 'square', 0.2); // G4
                setTimeout(() => this.playNote(523, 0.1, 'square', 0.2), 50); // C5
                setTimeout(() => this.playNote(659, 0.15, 'square', 0.2), 100); // E5
            }

            playPullRequestEvent() {
                // Two-tone chime - collaborative sound
                this.playNote(523, 0.2, 'sine', 0.3); // C5
                setTimeout(() => this.playNote(659, 0.3, 'sine', 0.3), 150); // E5
            }

            playIssuesEvent() {
                // Alert-like beep - attention needed
                this.playNote(880, 0.1, 'triangle', 0.25); // A5
                setTimeout(() => this.playNote(880, 0.1, 'triangle', 0.25), 150);
            }

            playWatchEvent() {
                // Soft ping - star/watch notification
                this.playNote(1047, 0.15, 'sine', 0.2); // C6
            }

            playForkEvent() {
                // Split/branch sound - two diverging tones
                this.playNote(440, 0.15, 'sawtooth', 0.15); // A4
                setTimeout(() => {
                    this.playNote(554, 0.2, 'sawtooth', 0.12); // C#5
                    this.playNote(330, 0.2, 'sawtooth', 0.12); // E4
                }, 100);
            }

            playCreateEvent() {
                // Ascending sparkle - something new created
                this.playNote(523, 0.08, 'sine', 0.2); // C5
                setTimeout(() => this.playNote(659, 0.08, 'sine', 0.2), 60); // E5
                setTimeout(() => this.playNote(784, 0.08, 'sine', 0.2), 120); // G5
                setTimeout(() => this.playNote(1047, 0.15, 'sine', 0.25), 180); // C6
            }

            playDeleteEvent() {
                // Descending tone - removal sound
                this.playNote(587, 0.1, 'triangle', 0.2); // D5
                setTimeout(() => this.playNote(440, 0.1, 'triangle', 0.2), 80); // A4
                setTimeout(() => this.playNote(330, 0.15, 'triangle', 0.2), 160); // E4
            }

            playReleaseEvent() {
                // Fanfare - celebration sound
                this.playNote(523, 0.1, 'square', 0.2); // C5
                setTimeout(() => this.playNote(659, 0.1, 'square', 0.2), 100); // E5
                setTimeout(() => this.playNote(784, 0.1, 'square', 0.2), 200); // G5
                setTimeout(() => this.playNote(1047, 0.3, 'square', 0.25), 300); // C6
            }

            playCommentEvent() {
                // Chat bubble pop
                this.playNote(698, 0.08, 'sine', 0.2); // F5
                setTimeout(() => this.playNote(880, 0.12, 'sine', 0.2), 60); // A5
            }

            playDefaultEvent() {
                // Generic notification blip
                this.playNote(600, 0.1, 'sine', 0.15);
            }

            // Play sound based on event type
            playEventSound(eventType) {
                switch (eventType) {
                    case 'PushEvent':
                        this.playPushEvent();
                        break;
                    case 'PullRequestEvent':
                        this.playPullRequestEvent();
                        break;
                    case 'IssuesEvent':
                        this.playIssuesEvent();
                        break;
                    case 'WatchEvent':
                        this.playWatchEvent();
                        break;
                    case 'ForkEvent':
                        this.playForkEvent();
                        break;
                    case 'CreateEvent':
                        this.playCreateEvent();
                        break;
                    case 'DeleteEvent':
                        this.playDeleteEvent();
                        break;
                    case 'ReleaseEvent':
                        this.playReleaseEvent();
                        break;
                    case 'IssueCommentEvent':
                    case 'CommitCommentEvent':
                    case 'PullRequestReviewCommentEvent':
                        this.playCommentEvent();
                        break;
                    default:
                        this.playDefaultEvent();
                }
            }
        }

        class GitHubSportscaster {
            // Configuration constants for activity scoring
            static EVENT_WEIGHTS = {
                PushEvent: 3,
                PullRequestEvent: 5,
                IssuesEvent: 2,
                ReleaseEvent: 10,
                ForkEvent: 4,
                WatchEvent: 1,
                CreateEvent: 2,
                DeleteEvent: 1,
                IssueCommentEvent: 1,
                CommitCommentEvent: 1
            };

            // Recency bonus configuration
            static VERY_RECENT_HOURS = 1;
            static RECENT_HOURS = 24;
            static VERY_RECENT_MULTIPLIER = 1.5;
            static RECENT_MULTIPLIER = 1.2;
            static CONTRIBUTOR_BONUS_MULTIPLIER = 2;

            // Rate limit protection thresholds
            static RATE_LIMIT_WARNING = 30;
            static RATE_LIMIT_DANGER = 10;
            static THROTTLE_INTERVAL = 30000; // 30 seconds when throttled

            constructor() {
                this.events = [];
                this.repositories = new Map(); // Track stats per repository
                this.maxEvents = 50;
                this.totalEvents = 0;
                this.baseUpdateInterval = 10000; // Base 10 seconds
                this.updateInterval = 10000;
                this.demoMode = false;
                this.failedAttempts = 0;
                this.seenEventIds = new Set();
                this.latestEvent = null;
                this.previousRanks = new Map(); // Track rank changes
                this.soundEffects = new SoundEffects();
                this.etag = null; // For conditional requests
                this.lastModified = null;
                this.rateLimit = { remaining: null, limit: null, reset: null };
                this.countdownInterval = null;
                this.fetchInterval = null;
                this.secondsUntilRefresh = 0;
                this.autoProtect = true;
                this.isThrottled = false;
                this.init();
            }

            async init() {
                this.setupSoundToggle();
                this.setupSpeedControl();
                this.startCountdown();
                await this.fetchActivity();
                this.startFetchInterval();
            }

            startFetchInterval() {
                if (this.fetchInterval) {
                    clearInterval(this.fetchInterval);
                }
                this.fetchInterval = setInterval(() => this.fetchActivity(), this.updateInterval);
            }

            setupSpeedControl() {
                const slider = document.getElementById('speed-slider');
                const valueDisplay = document.getElementById('speed-value');
                const autoProtectCheckbox = document.getElementById('auto-protect');

                slider.addEventListener('input', () => {
                    const seconds = parseInt(slider.value, 10);
                    valueDisplay.textContent = `${seconds}s`;
                    this.baseUpdateInterval = seconds * 1000;
                    
                    // Only update actual interval if not throttled
                    if (!this.isThrottled) {
                        this.updateInterval = this.baseUpdateInterval;
                        this.startFetchInterval();
                        this.startCountdown();
                    }
                });

                autoProtectCheckbox.addEventListener('change', () => {
                    this.autoProtect = autoProtectCheckbox.checked;
                    if (!this.autoProtect) {
                        // Disable throttling when auto-protect is off
                        this.isThrottled = false;
                        document.getElementById('rate-protected').style.display = 'none';
                        this.updateInterval = this.baseUpdateInterval;
                        this.startFetchInterval();
                        this.startCountdown();
                    }
                });
            }

            checkRateLimitProtection() {
                if (!this.autoProtect || this.rateLimit.remaining === null) {
                    return;
                }

                const rateProtectedEl = document.getElementById('rate-protected');

                // If rate limit is low, throttle the requests
                if (this.rateLimit.remaining <= GitHubSportscaster.RATE_LIMIT_DANGER) {
                    if (!this.isThrottled) {
                        this.isThrottled = true;
                        this.updateInterval = GitHubSportscaster.THROTTLE_INTERVAL;
                        rateProtectedEl.style.display = 'inline';
                        rateProtectedEl.textContent = '‚ö†Ô∏è Throttled (low rate limit)';
                        this.startFetchInterval();
                        this.startCountdown();
                    }
                } else if (this.isThrottled && this.rateLimit.remaining > GitHubSportscaster.RATE_LIMIT_WARNING) {
                    // Resume normal speed when rate limit recovers
                    this.isThrottled = false;
                    this.updateInterval = this.baseUpdateInterval;
                    rateProtectedEl.style.display = 'none';
                    this.startFetchInterval();
                    this.startCountdown();
                }
            }

            setupSoundToggle() {
                const toggleBtn = document.getElementById('sound-toggle');
                toggleBtn.addEventListener('click', () => {
                    const enabled = this.soundEffects.toggle();
                    toggleBtn.textContent = enabled ? 'üîä' : 'üîá';
                    toggleBtn.classList.toggle('muted', !enabled);
                    // Resume audio context on user interaction
                    this.soundEffects.resumeContext();
                });
            }

            startCountdown() {
                this.secondsUntilRefresh = this.updateInterval / 1000;
                this.updateCountdownDisplay();
                
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                }
                
                this.countdownInterval = setInterval(() => {
                    this.secondsUntilRefresh--;
                    if (this.secondsUntilRefresh < 0) {
                        this.secondsUntilRefresh = 0;
                    }
                    this.updateCountdownDisplay();
                }, 1000);
            }

            updateCountdownDisplay() {
                const countdownEl = document.getElementById('countdown');
                const progressBar = document.getElementById('progress-bar');
                
                if (countdownEl) {
                    countdownEl.textContent = this.secondsUntilRefresh;
                }
                
                if (progressBar) {
                    const progress = (this.secondsUntilRefresh / (this.updateInterval / 1000)) * 100;
                    progressBar.style.width = `${progress}%`;
                    progressBar.classList.remove('loading');
                }
            }

            updateRateLimitDisplay() {
                const remainingEl = document.getElementById('rate-remaining');
                const limitEl = document.getElementById('rate-limit');
                const resetEl = document.getElementById('rate-reset');
                
                if (this.rateLimit.remaining !== null) {
                    remainingEl.textContent = this.rateLimit.remaining;
                    limitEl.textContent = this.rateLimit.limit;
                    
                    // Add warning colors based on remaining requests
                    remainingEl.classList.remove('warning', 'danger');
                    if (this.rateLimit.remaining <= GitHubSportscaster.RATE_LIMIT_DANGER) {
                        remainingEl.classList.add('danger');
                    } else if (this.rateLimit.remaining <= GitHubSportscaster.RATE_LIMIT_WARNING) {
                        remainingEl.classList.add('warning');
                    }

                    // Check if we need to throttle
                    this.checkRateLimitProtection();
                }
                
                if (this.rateLimit.reset !== null) {
                    const now = Math.floor(Date.now() / 1000);
                    const secondsUntilReset = Math.max(0, this.rateLimit.reset - now);
                    const minutes = Math.floor(secondsUntilReset / 60);
                    const seconds = secondsUntilReset % 60;
                    resetEl.textContent = `${minutes}m ${seconds}s`;
                }
            }

            generateMockEvent(repoName, eventType) {
                const id = Math.floor(Math.random() * 1000000000) + Date.now();
                return {
                    id: id.toString(),
                    repo: {
                        id: Math.floor(Math.random() * 1000000),
                        name: repoName
                    },
                    type: eventType,
                    created_at: new Date().toISOString(),
                    actor: {
                        login: 'demo-user-' + Math.floor(Math.random() * 100),
                        avatar_url: 'https://github.com/ghost.png'
                    },
                    payload: this.generateMockPayload(eventType)
                };
            }

            generateMockPayload(eventType) {
                const payloads = {
                    PushEvent: { size: Math.floor(Math.random() * 5) + 1, commits: [] },
                    PullRequestEvent: { action: ['opened', 'closed', 'merged'][Math.floor(Math.random() * 3)] },
                    IssuesEvent: { action: ['opened', 'closed', 'reopened'][Math.floor(Math.random() * 3)] },
                    WatchEvent: { action: 'started' },
                    ForkEvent: {},
                    CreateEvent: { ref_type: ['branch', 'tag', 'repository'][Math.floor(Math.random() * 3)] },
                    DeleteEvent: { ref_type: ['branch', 'tag'][Math.floor(Math.random() * 2)] },
                    ReleaseEvent: { action: 'published' },
                    IssueCommentEvent: { action: 'created' }
                };
                return payloads[eventType] || {};
            }

            getMockEvents() {
                const repos = [
                    'facebook/react', 'microsoft/vscode', 'vercel/next.js', 
                    'nodejs/node', 'tensorflow/tensorflow', 'kubernetes/kubernetes',
                    'rust-lang/rust', 'golang/go', 'python/cpython', 
                    'microsoft/TypeScript', 'angular/angular', 'vuejs/vue',
                    'torvalds/linux', 'electron/electron', 'webpack/webpack'
                ];
                const eventTypes = [
                    'PushEvent', 'PullRequestEvent', 'IssuesEvent', 
                    'WatchEvent', 'ForkEvent', 'CreateEvent',
                    'IssueCommentEvent', 'ReleaseEvent', 'DeleteEvent'
                ];
                
                const events = [];
                const count = Math.floor(Math.random() * 5) + 3;
                for (let i = 0; i < count; i++) {
                    const randomRepo = repos[Math.floor(Math.random() * repos.length)];
                    const randomType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
                    events.push(this.generateMockEvent(randomRepo, randomType));
                }
                
                // Simulate rate limit for demo mode
                this.rateLimit = {
                    remaining: Math.floor(Math.random() * 30) + 30,
                    limit: 60,
                    reset: Math.floor(Date.now() / 1000) + 3600
                };
                this.updateRateLimitDisplay();
                
                return events;
            }

            async fetchActivity() {
                const progressBar = document.getElementById('progress-bar');
                if (progressBar) {
                    progressBar.classList.add('loading');
                }
                
                try {
                    let events;
                    
                    if (this.demoMode) {
                        events = this.getMockEvents();
                    } else {
                        // Build headers for conditional request
                        const headers = {};
                        if (this.etag) {
                            headers['If-None-Match'] = this.etag;
                        }
                        if (this.lastModified) {
                            headers['If-Modified-Since'] = this.lastModified;
                        }
                        
                        // Try to fetch from GitHub API with per_page=100 for maximum data
                        const response = await fetch('https://api.github.com/events?per_page=100', { headers });
                        
                        // Extract rate limit info from headers
                        const remaining = response.headers.get('X-RateLimit-Remaining');
                        const limit = response.headers.get('X-RateLimit-Limit');
                        const reset = response.headers.get('X-RateLimit-Reset');
                        
                        if (remaining !== null) {
                            this.rateLimit.remaining = parseInt(remaining, 10);
                            this.rateLimit.limit = parseInt(limit, 10);
                            this.rateLimit.reset = parseInt(reset, 10);
                            this.updateRateLimitDisplay();
                        }
                        
                        // Store ETag and Last-Modified for conditional requests
                        const newEtag = response.headers.get('ETag');
                        const newLastModified = response.headers.get('Last-Modified');
                        if (newEtag) this.etag = newEtag;
                        if (newLastModified) this.lastModified = newLastModified;
                        
                        // 304 Not Modified - no new data, don't count against rate limit
                        if (response.status === 304) {
                            console.log('No new events (304 Not Modified)');
                            this.startCountdown();
                            document.getElementById('loading').style.display = 'none';
                            return;
                        }
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        events = await response.json();
                        this.failedAttempts = 0;
                    }

                    this.processEvents(events);
                    this.render();
                    
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'none';
                    
                } catch (error) {
                    console.error('Error fetching GitHub events:', error);
                    this.failedAttempts++;
                    
                    if (this.failedAttempts >= 2 && !this.demoMode) {
                        this.demoMode = true;
                        console.log('Switching to demo mode with mock data');
                        const errorDiv = document.getElementById('error');
                        errorDiv.textContent = 'Running in demo mode with simulated data';
                        errorDiv.style.display = 'block';
                        setTimeout(() => {
                            errorDiv.style.display = 'none';
                        }, 3000);
                        return this.fetchActivity();
                    }
                    
                    const errorDiv = document.getElementById('error');
                    errorDiv.textContent = `Error loading data: ${error.message}. Retrying...`;
                    errorDiv.style.display = 'block';
                }
                
                // Reset countdown after fetch completes
                this.startCountdown();
            }

            processEvents(events) {
                const newEvents = [];

                events.forEach(event => {
                    if (!event || !event.id || !event.repo || !event.repo.name || !event.type || !event.created_at) {
                        return;
                    }

                    const eventId = event.id;
                    
                    if (this.seenEventIds.has(eventId)) {
                        return;
                    }

                    this.seenEventIds.add(eventId);
                    
                    const processedEvent = {
                        id: eventId,
                        repoName: event.repo.name,
                        repoUrl: `https://github.com/${event.repo.name}`,
                        eventType: event.type,
                        createdAt: new Date(event.created_at),
                        isNew: true,
                        actor: event.actor ? event.actor.login : 'unknown',
                        payload: event.payload || {}
                    };

                    newEvents.push(processedEvent);
                    this.totalEvents++;

                    // Update repository stats
                    this.updateRepositoryStats(processedEvent);

                    // Play sound effect for this event
                    this.soundEffects.playEventSound(event.type);
                });

                newEvents.sort((a, b) => b.createdAt - a.createdAt);

                // Merge new events with existing and sort
                const allEvents = [...newEvents, ...this.events];
                allEvents.sort((a, b) => b.createdAt - a.createdAt);
                this.events = allEvents;

                if (this.events.length > this.maxEvents) {
                    this.events = this.events.slice(0, this.maxEvents);
                }

                if (newEvents.length > 0) {
                    // Find the newest event by date
                    const newestEvent = newEvents.reduce((a, b) => 
                        a.createdAt > b.createdAt ? a : b
                    );
                    this.latestEvent = newestEvent;
                }

                this.newEventIds = new Set(newEvents.map(e => e.id));

                document.getElementById('event-count').textContent = this.totalEvents;
                document.getElementById('repo-count').textContent = this.repositories.size;
                document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
            }

            updateRepositoryStats(event) {
                const repoName = event.repoName;
                
                if (!this.repositories.has(repoName)) {
                    this.repositories.set(repoName, {
                        name: repoName,
                        url: event.repoUrl,
                        totalEvents: 0,
                        eventCounts: {},
                        recentEvents: [],
                        firstSeen: event.createdAt,
                        lastActivity: event.createdAt,
                        contributors: new Set(),
                        activityScore: 0
                    });
                }

                const repo = this.repositories.get(repoName);
                repo.totalEvents++;
                repo.lastActivity = event.createdAt;
                
                // Track event type counts
                if (!repo.eventCounts[event.eventType]) {
                    repo.eventCounts[event.eventType] = 0;
                }
                repo.eventCounts[event.eventType]++;

                // Track recent events (keep last 5)
                repo.recentEvents.unshift({
                    type: event.eventType,
                    time: event.createdAt,
                    actor: event.actor
                });
                if (repo.recentEvents.length > 5) {
                    repo.recentEvents.pop();
                }

                // Track contributors
                if (event.actor) {
                    repo.contributors.add(event.actor);
                }

                // Calculate activity score (weighted by recency and event type)
                this.calculateActivityScore(repo);
            }

            calculateActivityScore(repo) {
                const now = new Date();
                let score = 0;

                // Use class-level event weights for maintainability
                Object.entries(repo.eventCounts).forEach(([type, count]) => {
                    const weight = GitHubSportscaster.EVENT_WEIGHTS[type] || 1;
                    score += count * weight;
                });

                // Bonus for recent activity using named constants
                const hoursSinceLastActivity = (now - repo.lastActivity) / (1000 * 60 * 60);
                if (hoursSinceLastActivity < GitHubSportscaster.VERY_RECENT_HOURS) {
                    score *= GitHubSportscaster.VERY_RECENT_MULTIPLIER;
                } else if (hoursSinceLastActivity < GitHubSportscaster.RECENT_HOURS) {
                    score *= GitHubSportscaster.RECENT_MULTIPLIER;
                }

                // Bonus for contributor diversity
                score += repo.contributors.size * GitHubSportscaster.CONTRIBUTOR_BONUS_MULTIPLIER;

                repo.activityScore = Math.round(score);
            }

            getEventIcon(eventType) {
                const icons = {
                    PushEvent: 'üì§',
                    PullRequestEvent: 'üîÄ',
                    IssuesEvent: 'üêõ',
                    WatchEvent: '‚≠ê',
                    ForkEvent: 'üç¥',
                    CreateEvent: '‚ú®',
                    DeleteEvent: 'üóëÔ∏è',
                    ReleaseEvent: 'üéâ',
                    IssueCommentEvent: 'üí¨',
                    CommitCommentEvent: 'üí≠',
                    PullRequestReviewEvent: 'üëÄ',
                    PullRequestReviewCommentEvent: 'üí¨',
                    GollumEvent: 'üìù',
                    MemberEvent: 'üë•',
                    PublicEvent: 'üåê'
                };
                return icons[eventType] || 'üìå';
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            formatEventType(type) {
                return type.replace('Event', '').replace(/([A-Z])/g, ' $1').trim();
            }

            formatTime(date) {
                const now = new Date();
                const diff = Math.floor((now - date) / 1000);
                
                if (diff < 60) return `${diff}s ago`;
                if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
                if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
                return `${Math.floor(diff / 86400)}d ago`;
            }

            formatNumber(num) {
                if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
                return num.toString();
            }

            getTrendingIndicator(repoName, currentRank) {
                const previousRank = this.previousRanks.get(repoName);
                
                if (previousRank === undefined) {
                    return { class: 'trending-stable', icon: 'üÜï', text: 'New' };
                }
                
                if (currentRank < previousRank) {
                    const diff = previousRank - currentRank;
                    return { class: 'trending-up', icon: 'üìà', text: `+${diff}` };
                } else if (currentRank > previousRank) {
                    const diff = currentRank - previousRank;
                    return { class: 'trending-down', icon: 'üìâ', text: `-${diff}` };
                }
                
                return { class: 'trending-stable', icon: '‚û°Ô∏è', text: '‚Äî' };
            }

            getEventUrl(event) {
                // Generate a URL to the actual event on GitHub
                const baseUrl = event.repoUrl;
                switch (event.eventType) {
                    case 'PushEvent':
                        return `${baseUrl}/commits`;
                    case 'PullRequestEvent':
                        return `${baseUrl}/pulls`;
                    case 'IssuesEvent':
                        return `${baseUrl}/issues`;
                    case 'ReleaseEvent':
                        return `${baseUrl}/releases`;
                    case 'ForkEvent':
                        return `${baseUrl}/forks`;
                    case 'WatchEvent':
                        return `${baseUrl}/stargazers`;
                    case 'CreateEvent':
                    case 'DeleteEvent':
                        return `${baseUrl}`;
                    case 'IssueCommentEvent':
                    case 'CommitCommentEvent':
                        return `${baseUrl}/issues`;
                    default:
                        return baseUrl;
                }
            }

            updateAnnouncement() {
                const announcementDiv = document.getElementById('announcement');
                
                if (!this.latestEvent) {
                    announcementDiv.innerHTML = '<div class="no-announcement">Waiting for activity...</div>';
                    return;
                }

                const event = this.latestEvent;
                const icon = this.getEventIcon(event.eventType);
                const eventUrl = this.getEventUrl(event);
                announcementDiv.innerHTML = `
                    <div class="announcement-event-type">${icon} ${this.escapeHtml(this.formatEventType(event.eventType))}</div>
                    <div class="announcement-repo">
                        <a href="${this.escapeHtml(event.repoUrl)}" target="_blank" rel="noopener noreferrer">${this.escapeHtml(event.repoName)}</a>
                    </div>
                    <div class="announcement-time">
                        <span>by ${this.escapeHtml(event.actor)} ‚Ä¢ ${this.escapeHtml(this.formatTime(event.createdAt))}</span>
                        <a href="${this.escapeHtml(eventUrl)}" target="_blank" rel="noopener noreferrer" class="view-link">üîó View</a>
                    </div>
                `;
            }

            render() {
                const listContainer = document.getElementById('event-list');
                
                // Update sportscaster announcement
                this.updateAnnouncement();
                
                // Clear existing event list
                listContainer.innerHTML = '';

                // Sort events by date for display (newest first)
                const sortedEvents = [...this.events].sort((a, b) => b.createdAt - a.createdAt);

                // Calculate max score for activity bar scaling - handle empty repositories case
                const repoScores = Array.from(this.repositories.values()).map(r => r.activityScore);
                const highestActivityScore = repoScores.length > 0 ? Math.max(...repoScores) : 1;

                sortedEvents.forEach((event, index) => {
                    const isNew = this.newEventIds && this.newEventIds.has(event.id);
                    const icon = this.getEventIcon(event.eventType);
                    const repo = this.repositories.get(event.repoName);

                    const item = document.createElement('div');
                    item.className = 'event-item';
                    // Sanitize event ID for valid HTML ID attribute
                    item.id = `event-${String(event.id).replace(/[^a-zA-Z0-9-_]/g, '-')}`;

                    if (isNew) {
                        item.classList.add('new-event', 'stagger-in');
                        const staggerDelay = Math.random() * 2000;
                        item.style.animationDelay = `${staggerDelay}ms`;
                    }

                    // Build compact stats HTML for this repo
                    let statsHtml = '';
                    if (repo && highestActivityScore > 0) {
                        const activityPercent = Math.round((repo.activityScore / highestActivityScore) * 100);
                        const trending = this.getTrendingIndicator(repo.name, index + 1);
                        
                        // Build mini event type tags (top 3)
                        const eventTagsHtml = Object.entries(repo.eventCounts)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 3)
                            .map(([type, count]) => `<span class="mini-tag">${this.getEventIcon(type)}<span class="mini-tag-count">${count}</span></span>`)
                            .join('');

                        statsHtml = `
                            <div class="event-stats">
                                <span class="stat-pill" title="Total Events">
                                    <span class="stat-pill-icon">üìä</span>
                                    <span class="stat-pill-value">${repo.totalEvents}</span>
                                </span>
                                <span class="stat-pill" title="Contributors">
                                    <span class="stat-pill-icon">üë•</span>
                                    <span class="stat-pill-value">${repo.contributors.size}</span>
                                </span>
                                <span class="stat-pill" title="Activity Score">
                                    <span class="stat-pill-icon">‚ö°</span>
                                    <span class="stat-pill-value">${repo.activityScore}</span>
                                </span>
                                <div class="mini-activity-bar" title="Activity Level ${activityPercent}%">
                                    <div class="mini-activity-fill" style="width: ${activityPercent}%"></div>
                                </div>
                            </div>
                        `;
                    }

                    item.innerHTML = `
                        <div class="event-item-row">
                            <div class="event-number">${index + 1}</div>
                            <div class="event-details">
                                <div class="event-repo-name">
                                    <a href="${this.escapeHtml(event.repoUrl)}" target="_blank" rel="noopener noreferrer">${this.escapeHtml(event.repoName)}</a>
                                </div>
                                <div class="event-meta">
                                    <span class="event-type">${icon} ${this.escapeHtml(this.formatEventType(event.eventType))}</span>
                                    <span class="event-time">by ${this.escapeHtml(event.actor)} ‚Ä¢ ${this.escapeHtml(this.formatTime(event.createdAt))}</span>
                                </div>
                            </div>
                            ${statsHtml}
                        </div>
                    `;

                    listContainer.appendChild(item);
                });

                this.newEventIds = new Set();
                this.events.forEach(e => e.isNew = false);
            }
        }

        // Initialize the sportscaster when page loads
        window.addEventListener('DOMContentLoaded', () => {
            new GitHubSportscaster();
        });
    </script>
</body>
</html>
